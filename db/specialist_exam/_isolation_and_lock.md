# トランザクションとACID特性
- トランザクション
  - ユーザーから見た一連の処理のまとまり
- ACID特性
  - トランザクションが持つ特性で、これによりトランザクションの信頼性が得られる

|ACID特性|意味|実現するための仕組み|
|-|-|-|
|原子性(Atomicity)|トランザクションは完全に実行されるor実行されない<br>中途半端はダメ|コミットメント制御|
|一貫性(Consistency)|トランザクションはDB内で整合性が保たれないければならない|排他制御(同時実行制御)|
|独立性(Isolation)|トランザクションは同時に実行している他のトランザクションから影響を受けず、並列実行の場合も単独実行の場合も同じ結果にならなればならない|排他制御(同時実行制御)|
|耐久性(Durability)|トランザクションの結果は、障害発生時にも失わないようにしなければならない|障害回復|

## コミットメント制御
- コミット
  - トランザクション内の処理が全て実行された時に、その更新結果を確定すること
- ロールバック
  - トランザクションの途中で何らかのエラーが発生したときに、処理を取り消し、トランザクション開始前の状態にすること

## 排他制御(=同時実行制御)
- DBMSでは、複数のトランザクションを実行できるようにしているが、何の制御もせずに同時実行すると同じテーブルに対して参照・更新を行うときに誤った結果になることがある
  - ロストアップデート
    - e.g. あるレコードの値10に対して、トランザクションAとトランザクションBがそれぞれ10を加える処理を実行したとする。本来は30とならなければならないところが、トランザクションAがトランザクションBに上書きされてしまい、20となってしまう。
  - 誤った更新
    - ISOLATIONのレベルにもよるが、①対象データの読み取り → ②更新処理の判断 → ③更新という処理をするときに、①で読み取ったデータが、②の更新処理の判断までに別のトランザクションによって更新されてしまうと、②更新処理の判断が誤ったものになり、③で本来行ってはいけない更新を行なってしまうことがある。(READ COMMITTED以下だと起こりうる)
- 直列化可能性
  - 二つのトランザクションT1とT2を並列に実行した結果が、それぞれ逐次実行したときの結果と等しい場合、このトランザクションスケジュールは直列化可能性が保証されているという
  - トランザクションT1とT2の処理内容をもとに保証されているかどうかを判断する
  - 混同しやすい概念として、逐次処理というものがある。これは、複数トランザクションがあったときに、順番に実行した場合、同じ結果となるように並列実行するスケジュールを組むこと
- ロックの種類（重要！！）
  - 共有ロック
    - 他のトランザクションから対象行に対する参照は可能だが、更新はロックの解放待ちとなる
  - 専有ロック
    - 他のトランザクションからの参照および更新ができず、ロックの解放待ちとなる
  - **勘違いしていたこと**
    - 既に共有ロックがかかっている時、新たに共有ロックはかけられるが専有ロックはかけられないというのは有名である。しかし、このときの挙動を正しく理解していないと、デットロックが発生してしまう。
    - 例）
      - トランザクションAがある行のデータに対して読み取りを行い共有ロックをかける
      - この時、ISOLATIONのレベルがREAD UNCOMMITTEDまたは、READ COMMITTEDであれば、読み取った時に共有ロックが外れる。一方、REPEATABLE READの場合はトランザクション全体が終わるまで共有ロックをかけ続ける。(←デットロックが発生するのはこのパターン)
      - トランザクションBが共有ロックがかかったままのデータ行に対して読み取りを行うと、トランザクションBも対象行に共有ロックをかける。**ここで勘違いしていたのは、トランザクションBが共有ロックをかけるとトランザクションAがかけていた共有ロックはかかったままで新たな共有ロックがかけられることになる。**
      - 処理の流れが、①読み取り②更新という2つの処理からなるトランザクションA、Bがあるとして、まずAが対象の行に対して①を行い、次にBが同一の行に対して①を行うと、対象行には共有ロックAと共有ロックBがかかることになる。そのため、トランザクションAとBが②を行おうとすると、相手の共有ロックが邪魔でデットロックが起こる。
- ２相ロックと２相ロッキングプロトロコル
  - ２相ロック
    - ロックのかけ方たによって、直列可能であることが保証できないことがある。
    - そこで、確実に直列可能性を保証したい場合に使うのが２相ロック方式。
    - ロックを獲得する相と解放する層を分割することで実現する。分割するルールのため、一度ロックを解放したら再度ロックを取得することはできない。
    - １相目：拡張相
      - 書き込み・読み込みを行いたいデータに対して、ロック取得していく
      ```
      Lock a
      Update a

      Lock b
      Update b

      Lock c
      Update c
      ```
    - ２相目：縮退相
      - ロックを全て解放する
      ```
      UNLOCK a
      UNLOCK b
      UNLOCK c
      ```
- デットロック
  - 二つ（複数）のトラザクションがお互いの処理に必要なデータをロックし合っているために、処理が続行できなくなった状態
  - 回避方法
    - **複数のトランザクションが共有資源にアクセスする際にロックをかけて処理する順番を同じにする。**（テーブルうを処理する順番を同じにしたり、同一テーブルは必ず昇順に処理するなど）
    - トランザクションの単位を見直す
      - 不必要に大きなトランザクションとなっていてロックをかけてしまわないようにする
  - 検出方法
    - 待ちグラフ
      - デッドロックを検出するために使われるデータ構造
      - トランザクションAからトランザクションBへの矢印の向きがロックの解放待ちを表していて、すべてのトランザクションで待ちグラフを作成したときに、すべてのトランザクションが何からしらのロックの解放待ちをしている場合デッドロックが発生している。
- ロック以外の排他方式(=同時実行方式)
  - 時刻印アルゴリズム
    - 複数のトランザクションで競合した場合、先に実行した方から順番に実行し、後の方は一度アボートしてから再実行する。トランザクションで共有するデータが少ない場合有効。
  - 楽観アルゴリズム
    - 書き込み処理を行うまでは排他制御の操作を行わず、データの書き込みが発生したタイミングで初めて、そのデータが他のトランザクションが更新しデータと同じでないかチェックして更新していないければそのまま実行。更新していたトランザクションをロールバックしてやり直し。