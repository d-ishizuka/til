## デッドロック

- デッドロックを考慮する場合の要素は大きく分けて3つ
  - 1. ISOLATIONレベル
  - 2. 処理の順番
  - 3. トランザクション処理の単位

### ISOLATIONレベル
- 4つのレベルによって、鍵のかけ方(共有ロック、占有ロック)が異なる。
  - 例えば、READ COMMITTEDだと読み込みの瞬間に共有ロックをかけるが、読み込んだらすぐにロックを外す。一方で、REPEATABLE READでは、読み込んだ瞬間に共有ロックをかけつつ、トランザクションの最後までロックをかけ続ける。
  - そのため、ある行に対して共有ロックをかけた時の外れるタイミングが違うのでREPEATABLE READでは、読み込みだけでもデットロックの要因になりうる。

### 処理の順番
- あるトランザクションT1では、行Aと行Bの順に更新する。トランザクションT2では、行Bと行Aの順に更新する。
- この時、ロックは処理の順番にかかるのでトランザクションT1はT1同士をいくら実行してもデットロックは発生しない。（先に実行したトランザクションが行Aロック→行Bロック→コミットのタイミングでロック解除）
- 一方、トランザクションT1とT2を実行した場合は実行タイミングによってロックが掛かりうる。T1：行Aをロック→T2：行Bをロック→T1:行Aのロック解除待ち & T2：行Bのロック解除待ち

## トランザクジョン処理の単位
- 1つのトランザクションの中で、何行のレコードを操作するのか、どこまでを一括りとして処理したいのかによって変わってくる。
- 行を更新するときにトランザクションT1で１行だけを更新する場合、デットロックは発生しづらい。一方、トランザクションT2では、極端な話100行更新する処理を1つだとしているのであれば、その分デットロックは起こりやすい。