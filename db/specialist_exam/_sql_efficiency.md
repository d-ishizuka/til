
## ページをランダムに入出力する場合
- 具体的には、インデックスを使った検索を行う場合
- この場合、CPU処理とデータの入出力は同期的に行われるので、処理時間は和で表される
  - SQLの処理時間 = CPU処理時間 + 同期データ入出力処理時間
    - CPU処理
    - 同期データ入出力処理
      - 

## ページを順次入出力する場合
- 具体的には、テーブルスキャンをする場合
- この場合、CPU処理とデータの入出力は非同期的に行われるので、処理時間はいずれか長い方で表される
  - SQLの処理時間 = MAX(CPU処理時間 + 非同期データ入出力処理時間)
    - CPU処理
      - データ入力処理
        - 全データページを順次にデータバッファに入力するのに必要なCPU処理
          - テーブルスキャンとなる条件で```SELECT * FROM TABLE_NAME WHERE xxx```としたら全データをデータバッファに順次取り込む処理が行われる
      - データ出力処理
        - 全行をデータバッファからプログラム内に移動するのに必要なCPU処理
          - ヒットした件数が0件の場合行われない
      - イメージ
        - [プログラム] ← (CPUデータ出力処理) ← [データバッファ] ← (CPUデータ入力処理) ← [データページ(物理)]
    - 非同期データ入出力処理
      - データ入出力時間 = データ入力処理時間 + データ出力処理時間
      - データ入力処理
        - データページ(物理)を読み込むのにかかる時間(100MB/秒とかで読み込まれていくのにかかる時間)
      - データ出力処理
        - 外部ファイルに出力するのに必要な処理
          - 例えば、ログを出力する場合などはデータを物理的に出力する処理（ログの書き込み時間）
          - Updateなどで更新した結果を書き込む処理(更新書き込み時間)。Select(参照)だけだと発生しない。
      - イメージ
        - [外部ファイル(ログなど)] ← (データ出力処理) ← [プログラム] ← [バッファ] ← (データ入力処理) ← [データページ(物理)]

## 非クラスタ検索を行った時の処理の流れ(ChatGPT)

非クラスタインデックスを使って検索したデータを更新する際のSQLの処理、バッファ、物理ページの流れについては、以下のような段階を経て処理が進行します。これを理解するには、データベースエンジンの基本的な処理フロー（SQL実行、バッファ管理、ディスクI/O）を考慮します。

### 1. SQLの実行フェーズ
非クラスタインデックスを使って、検索からデータ更新までのSQL処理を順番に見ていきます。

#### 1.1 クエリの実行（検索）
SQL文の実行: 例えば、last_name = 'Smith'で該当するデータを検索し、結果を更新するSQL文を発行します。例: UPDATE persons SET first_name = 'John' WHERE last_name = 'Smith';
パーサーによる解析: データベースエンジンは、まずSQL文を受け取り、パーサーが文法をチェックします。
プランナーとオプティマイザ: クエリの実行計画が作成され、インデックスがあるかどうかが確認されます。この場合、last_nameに非クラスタインデックスが設定されているため、インデックススキャン（非クラスタインデックスに基づく検索）が選択されます。
#### 1.2 インデックススキャンによる検索
インデックスの検索: データベースは、非クラスタインデックスを使用して、last_name = 'Smith'に対応する行を検索します。非クラスタインデックスは、インデックスエントリ（last_name列の値と実データ行の物理アドレスを持つ参照）が含まれており、このインデックスから該当するデータの物理アドレス（行の位置）を取得します。


### 2. バッファ（メモリ）管理フェーズ
データベースは効率的なディスクI/Oを行うため、メモリバッファを使って読み込み・書き込み操作を行います。

#### 2.1 バッファキャッシュへの読み込み
ページの読み込み: インデックススキャンで得た物理アドレスをもとに、該当するデータが格納されているデータページを確認します。データがすでにメモリ上のバッファプールにキャッシュされていれば、そのページが使われます。そうでない場合、該当するページがディスクからメモリ上のバッファプールに読み込まれます（これをバッファキャッシュといいます）。
#### 2.2 ページのロックとデータの更新
ページのロック: 該当するページがバッファプールにロードされると、そのページに対して適切なロックが取得されます。ロックの種類はデータベースによって異なりますが、データを変更する場合には排他ロックがかかります。
データの更新: メモリ上のバッファに存在する該当のデータ行に対して、更新処理が行われます。ここでは、first_name列の値が 'John' に変更されます。更新されたデータは、すぐにディスクには書き込まれず、メモリ上のバッファに残ります。この状態を「ダーティページ」と呼びます。
#### 2.3 インデックスの更新
インデックスエントリの更新: 非クラスタインデックスが更新対象の列に対して有効である場合、インデックスエントリも同時に更新されます。今回の例ではlast_name列を検索キーとしているため、first_name列の変更ではインデックス自体は変更されませんが、もしインデックスの対象列が更新された場合、インデックスエントリも更新されます。

### 3. ディスク（物理ページ）への書き込みフェーズ
データベースのメモリバッファ管理とディスクI/Oの動作に関わる最後のフェーズです。

#### 3.1 データ書き込みの遅延（Lazy Write）
遅延書き込み: データベースは、頻繁なディスクI/Oを避けるため、メモリ上のバッファに一時的に更新データを保持し、バッチ処理としてディスクに書き込む方法を採用します。このため、変更されたページ（ダーティページ）はすぐにはディスクに書き込まれず、一定の間隔で書き戻されます。
#### 3.2 チェックポイントとディスクへの書き込み
チェックポイントの発生: データベースエンジンは、定期的にチェックポイントを実行します。この時点で、ダーティページがディスク上の適切な物理ページに書き込まれます。ページのデータがディスクに書き込まれると、そのページは再びクリーンな状態となります。
書き込み順序: 物理的なディスク書き込みは、データベースの書き込み戦略に基づいて行われ、ランダムアクセスを最小限に抑えるように最適化されています。
#### 3.3 トランザクションログへの書き込み
トランザクションログ: 更新処理が完了する前に、更新の内容がトランザクションログに記録されます。トランザクションの永続性を保証するため、ログは先にディスクに書き込まれます（この操作は即座に行われる）。
物理ページ書き込み: ログが書き込まれた後に、ダーティページがチェックポイントなどを契機にディスクに書き込まれます。このようにして、更新内容は永続化されます。

### 流れのまとめ
- SQLクエリの実行: インデックススキャンを利用して該当データを検索。
- バッファにデータロード: 該当するデータがバッファにロードされ、ロックがかかる。
- データ更新: メモリ上のバッファでデータが更新される（ダーティページが発生）。
- インデックス更新: 必要に応じて、関連するインデックスも更新。
- トランザクションログの書き込み: 更新内容がトランザクションログに書き込まれ、永続性が保証される。
- 遅延書き込みとチェックポイント: ダーティページが後でディスクに書き込まれ、最終的にデータが物理的に保存される。
- 
このように、非クラスタインデックスを利用したデータの更新では、インデックススキャンによりデータを特定し、メモリバッファ内で更新が行われ、その後ディスクへの書き込みが行われるという一連の流れが発生します。