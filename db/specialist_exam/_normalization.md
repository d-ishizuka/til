# 正規化

## 正規化の目的
- データの冗長性を排除して、独立性を高めるために行う。
- 正規化が不十分だと、テーブルへの新しい行を挿入する時や、不要になった行を削除するとき、更新するときに、様々な異状が発生する。(=更新時異状)
- 具体的には、「1 fact 1 place」にすることで更新時異状が発生しないようにする。

### 更新時異状の例
- 第２正規化されていない場合
  - 主キー：店舗ID, 商品ID
  - 関数従属性：店舗ID → 店舗名、商品ID → 商品名、{店舗ID,商品ID} → 在庫数

|店舗ID|店舗名|商品ID|商品名|在庫数|
|-|-|-|-|-|
|01|東京店|001|パソコンA|10|
|01|東京店|002|パソコンB|5|
|02|大阪店|001|パソコンA|8|
|03|名古屋店|003|パソコンC|2|

- 冗長性
  - このテーブルでは、「店舗ID: 001, 店舗: 東京店」と「商品ID: 001, 商品名: パソコンA」が複数箇所に存在している
- 挿入時の更新時異状
  - 在庫として保持する店舗が未決定の状態で、新規商品「商品ID: 004, 商品名：デジカメD」を在庫テーブルに挿入したい時、{店舗ID, 店舗名, 在庫数を}NULLにした状態で挿入することになるが、店舗IDは主キーの一部なので主キー制約に反する。つまり挿入できない。
- 修正時の更新時異状
  - 「商品ID: 001, 商品名: パソコンA」ではなく「商品ID: 001, 商品名: パソコンE」が正しい場合、修正が必要だが、同じ情報が存在する複数の行で同時に更新しないと整合性が失われる。
- 削除事の更新時異状
  - 名古屋店が閉店となったときに、該当する行を削除すると「商品ID: 003, 商品名: パソコンC」という情報が失われる。これを失わないように{店舗ID, 店舗名, 在庫数を}NULLにしようとすると主キー制約に反する。

- 第3正規化されていない場合
  - 主キー：ID
  - 関数従属性：役割ID→役職名称、社員ID→社員氏名、社員ID→役職ID

|社員ID|社員氏名|役職ID|役職名称|
|-|-|-|-|
|001|鈴木|905|社長室長|
|002|佐藤|106|課長|
|003|高橋|106|課長|

- 冗長性
  - 「役職ID：106, 役職名: "課長"」が複数箇所に存在しているため、役職情報{役職ID, 役職名称}に冗長性があると言える。
- 挿入時の更新時状態異状
  - 新しい役職「役職ID: 108, 役職名: "営業本部長"」の設置を計画していて、辞令を交付する社員は決まっていない時、{社員ID, 社員氏名}をNULLにして{役職ID, 役職名称}の関係を挿入しようとすると、主キー制約に反するため挿入できない。
- 修正時の更新時異状
  - 「役職ID: 106, 役職名: "課長"」を修正する際に、同じ情報が存在する行を更新しないと整合性が失われる
- 削除時の更新時異状
  - 鈴木さんが退職予定なので、その行を消すと「役職ID: 905, 役職名: "社長室長"」という情報が失われる。{社員ID, 社員氏名}をNULLにして更新しようとすると、主キー制約に反する。

### 更新時異状について指摘する問題
- 上記のように更新時異状が発生するのは、第３正規形まで正規化されていないことが原因。
- 状態としては、以下のような問題があるパターン
  - R(<u>A</u>, <u>B</u>, C, D)において、部分関数従属(B → C)が存在する ※第2正規形を満たさない
  - R(<u>A</u>, B, C)において、推移関数従属(B→C)が存在する　※第3正規形を満たさない
- 解答はタイミングによって変わってくる
  - A：挿入時...主キー{A, B}が未登録だとBとCまたはBに関して登録できない。
  - B：挿入時...主キー{A}が登録されている状況の場合、BとCまたはBに関して冗長になる。or 重複して登録するため不整合が生じる。
  - C：更新時...Aが異なり、Bが違うレコード間でBまたはBとCが冗長である。or 同時に修正しないと整合性が失われる
  - D：削除時...BとCの組み合わせ or Cの値が特定の１行にしかない場合、主キーになるAやBを削除すると、これらの情報が永久に失われる。

## 各種正規形の形とその指摘
### 0. 非正規形
- 定義：リレーションRのなかに、単一でない値が含まれている(=繰り返しの値が含まれている)
- 例えば、伝票を1つのレコードだと考えると、1つのレコードに各種商品の単価や個数が書いてある。つまり、１レコードの中に複数商品の繰り返し情報が入っている。
  - １行のレコードが、R(A, B, C, D)みたいに書けない
  - 無理やり書こうとすると、A:伝票番号, B:日付, C:繰り返しの商品情報, D:請求額みたいな感じになって、Cに複数レコードを詰め込むことになる
- 非正規形である理由の指摘(= 第一正規形ではない理由)
  - 属性〇〇が繰り返し項目であり単一値ではないから(22文字)

|伝票番号|日付|商品|請求額|
|-|-|-|-|
|1|2024-09-25|※|1000|
|2|2024-09-26|※|2000|...

※のところに、複数商品の繰り返し情報が入る。(テーブル in テーブルみたいな感じ)

### 1. 第1正規形
- 定義：リレーションRの全ての属性が単一値である。
- 要するに繰り返し構造を解消すれば良い。具体的には、商品1レコードに対して1行になるようにする。
- 第1正規形である理由の指摘(=第２正規形ではない理由)
  - 全ての属性が単一値で、候補キー{A, B}の一部であるBに対して非キー属性Cが部分関数従属するため

|OrderID|CustomerName|CustomerAddress|ProductID|ProductName|Quantity|	SupplierName|
|-|-|-|-|-|-|-|
|001|Alice|123 Maple St|P01|Laptop|1|TechCo|
|001|Alice|123 Maple St|P02|Mouse|2|GadgetPro
|002|Bob|456 Oak Ave|P01|Laptop|1|TechCo
|002|Bob|456 Oak Ave|P03|Keyboard|1|GadgetPro
|003|Charlie|789 Pine Blvd|P01|Laptop|2|TechCo

- この例では、OrderIDとProductIDで複合候補キーだが、OrderIDだけに従属している属性とProductIDだけに従属しているデータがあり、冗長になっている。
- イメージとしては、レシートのデータを一旦正規形にしてみたという状態なので、冗長な状態になっている。

### 2. 第2正規形
- 定義：
  - 1. 第1正規形であること
  - 2. 全ての非キーは、いかなる候補キーにも部分関数従属していない
    - つまり、複数の属性からなる候補キーがあったときに、どれか1つだけのキーに従属した属性はないということ。**どれか1つだけのキー従属した属性があるということは、その属性は独立してデータとして存在しているのに、単体でテーブルに保存できないことを意味している。(候補キーが実際に主キーだった場合は、主キー制約で全てのデータが揃わないとデータ挿入できないということになる)**
    - 一方で、ここで見ているのはあくまでも候補キー(主キー)との関係性を見た時の話で、非候補キー間の関係は言及していない。→ 第3正規形へ。
  - 第２正規形である理由の指摘(=第３正規形ではない理由)
    - 全ての属性が単一値で、候補キーからの部分関数従属がなく、推移的関数従属性A→B→Cがあるため
    - 回答字数が短い時は、候補キーからの...推移的関数従属性をメインに記述

- Orders テーブル

|OrderID|CustomerName|CustomerAddress|
|-|-|-|
|001|Alice|123 Maple St|
|002|Bob|456 Oak Ave|
|003|Charlie|789 Pine Blvd|

- OrderDetails テーブル

|OrderID|ProductID|Quantity|
|-|-|-|
|001|P01|1|
|001|P02|2|
|002|P01|1|
|002|P03|1|
|003|P01|2|

- Products テーブル

|ProductID|ProductName|SupplierName|
|-|-|-|
|P01|Laptop|TechCo|
|P02|Mouse|GadgetPro|
|P03|Keyboard|GadgetPro|

- この例では候補キー(主キー)に対する候補キーに対する部分関数従属はなくなった
- 一方で、OrdersテーブルのCustomerNameやCustomerAddress、ProductsテーブルのProductNameやSupplierNameに関しては推移関数従属が存在する
  - 非候補キー(非主キー)のCustomerName→CustomerAddress、ProductName→SupplierNameに関しては、推移関数従属が存在する 

### 3. 第3正規形
- 定義：
  - 1. 第２正規形であること
  - 2. 全ての非キー属性は、いかなる候補キーにも推移的関数従属していない
    - 推移的というのは、候補キーA → 属性B → 属性Cのようになっていることから推移的という
    - 結局のところ、ある非キーが別の非キーに従属していることを表している
    - この問題は、部分的関数従属と同じで冗長なのと、属性Bと属性Cで1つのデータなのに候補キーAがレコードとしてくっついているせいで、属性Bと属性Cでデータが保存することができない。
    - 部分的関数従属も推移的関数従属結局のところ、独立していたデータに対して、関係ない主キーを勝手にくっつけられて単体でレコードとして保存できなくなった状態
- 補足：
  - 合計や請求額、小計など導出項目は第３正規化のタイミングで取り除く
- 第3正規形である理由の指摘
  - 全ての属性が単一値で、候補キーからの部分関数従属がなく、推移的関数従属性もないため

- Products テーブル

|ProductID|ProductName|SupplierID|
|-|-|-|
|P01|Laptop|S01|
|P02|Mouse|S02|
|P03|Keyboard|S02|

- Suppliers テーブル

|SupplierID|SupplierName|
|-|-|
|S01|TechCo|
|S02|GadgetPro|

- Customers テーブル

|CustomerID|CustomerName|CustomerAddress|
|-|-|-|
|C001|Alice|123 Maple St|
|C002|Bob|456 Oak Ave|

- Orders テーブル
|OrderID|CustomerID|
|-|-|-|
|001|C001|
|002|C001|
|003|C002|

### 4. ボイス・コッド正規形
- 定義:リレーションRに存在するあらゆる関数従属性に関して、**次のいずれか**が成立する(X→Y)
  - 1. X → Yは自明な関数従属性である
  - 2. XはRのスーパーキーである
- 第３正規形でもあり、ボイス・コッド正規形でもある例
  - 顧客(<u>電話番号</u>、顧客名、住所、性別、生年月日)
    - 1. 電話番号(X)が、自明な関数従属かは不明
      - 電話番号 → 顧客名
      - 電話番号 → 住所
      - 電話番号 → 性別
      - 電話番号 → 生年月日
    - 2.電話番号(X)は、主キーなのでスーパーキーである
      - スーパーキーは行を特定できるための必要な情報
- 第３正規形ではあるが、ボイス・コッド正規形ではない例
  - 受講(学生, 科目, 教官)　また、教官 → 科目という関係性もある
    - 候補キーは、{学生, 科目}, {学生, 教官}
  - 1. 関数従属性が自明ではない関係をピックアップすると以下になったとする
    - {学生, 科目} → 教官
    - 教官 → 科目
  - 2. 
    - {学生, 科目} → 教官は主キーなので、スーパーキー
    - 教官 → 科目は、教官が候補キーの一部だが、候補キーではないのでスーパーキーではない
      - よって、ボイス・コッド正規形ではない
- ボイス・コッド正規形かどうかの見極め方
  - 候補キーが1つの場合は、第３正規形まで進めると勝手にボイス・コッド正規形になる
  - ボイス・コッドが問題になるのは、
    - 1. 候補キーがたくさんあり
    - 2. その中に、候補キーの一部が決定項(例：教官)となっている関数従属性がある


### 5. 第4正規形
### 6. 第5正規形